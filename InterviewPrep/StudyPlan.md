# 1 Month Study Guide
## Dynamic Programming
Understand the idea of storing intermediate results to avoid redundant calculations, optimizing recursive solutions, and understanding overlapping subproblems.

- Climbing Stairs - Understand basic recursion and memoization.
- Min Cost Climbing Stairs - Similar to Climbing Stairs, with a cost twist.
- Maximum Subarray - Introductory problem for contiguous subarray problems (Kadaneâ€™s algorithm).
- House Robber - Basic problem illustrating non-adjacent element picking with optimization.
- Fibonacci Number - Classic example to demonstrate the effectiveness of memoization.
## Two Pointers
Master the technique of using two pointers to reduce complexity, particularly in problems involving arrays or linked lists.

- <s>Two Sum II - Input Array Is Sorted - Basic two-pointer usage in a sorted array.
- Reverse String - In-place reversal demonstrating the two-pointer technique.
- Palindrome Linked List - Utilize two pointers to check for palindrome properties in a linked list.</s>
- Merge Sorted Array - A clear example of the two-pointer method in merging arrays.
- Backspace String Compare - Creative use of two pointers in a string comparison problem.

## Hash Map
Learn to use hash maps (objects in JavaScript) for fast data retrieval, frequency counting, and mapping relationships.

### Easy Problems

- <s>Two Sum - Classic problem for understanding the utility of hash maps in quick look-up.

- Contains Duplicate - Simple usage of a hash set to track uniqueness.

-  Group Anagrams - Grouping strings by character frequency using a hash map.

-  First Unique Character in a String - Find characters by building and querying a frequency map.

- Intersection of Two Arrays - Demonstrates efficient look-up and set operations. </s >

## Depth-First Search (DFS)
Get comfortable with recursion and backtracking, exploring all paths or possibilities to a certain depth.

Maximum Depth of Binary Tree - Basic introduction to tree traversal with DFS.
Path Sum - Check for path existence and sum computation in binary trees.
Flood Fill - Typical use case of DFS in a grid/matrix (similar to the paint bucket tool).
Binary Tree Paths - Finding all root-to-leaf paths in a binary tree using DFS.
Sum of Root To Leaf Binary Numbers - Calculating the sum from binary numbers formed by root to leaf paths.
Breadth-First Search (BFS)
Practice the BFS pattern, often used in shortest path problems or in scenarios where you need to traverse level by level.

Binary Tree Level Order Traversal - Classic problem to understand level-by-level traversal.
Minimum Depth of Binary Tree - Finding the shortest path to a leaf node.
Symmetric Tree - Leveraging BFS to check for symmetry in a binary tree.
Average of Levels in Binary Tree - Calculating averages at each level of a binary tree.
Find Largest Value in Each Tree Row - Identify the largest value at each level of a binary tree.
Binary Search
Develop an understanding of the binary search algorithm in sorted arrays, optimizing time complexity from O(n) to O(log n).

Binary Search - The fundamental problem to understand binary search.
First Bad Version - Application of binary search in a decision-making process.
Guess Number Higher or Lower - Implementing binary search in a guess-the-number game.
Search Insert Position - Binary search application to find the insert position in a sorted array.
Arranging Coins - Utilizing binary search to solve mathematical problems efficiently.
Math and Logic
Enhance your problem-solving skills with problems that require mathematical reasoning, logical deduction, or straightforward computation.

Fizz Buzz - A simple loop and conditionals problem focusing on modulo operation.
Count Primes - Mathematical understanding of prime numbers.
Roman to Integer - Basic math combined with string parsing.
Missing Number - Using mathematical formulae or bit manipulation to find the missing number.
Power of Three - Understanding loops, recursion, or mathematical properties of numbers.
Sorting
Learn sorting algorithms and understand how sorted data can significantly simplify the problem-solving process.

Merge Sorted Array - Merging two sorted arrays, understanding in-place sorting.
Contains Duplicate - Checking for duplicates in an array post-sorting.
Assign Cookies - Greedy approach with sorting to satisfy conditions optimally.
Kth Largest Element in a Stream - Utilizing sorting/min-heap to find the Kth largest element continuously
